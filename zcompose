#!/usr/bin/env python3

import asyncio
import io
import ipaddress
import logging
import os
import re
import sys
import subprocess

from dataclasses import asdict, dataclass, field
from pathlib import Path

import yaml
import tqdm

logger = logging.getLogger("zcompose")


def run_cmd(cmdline):
    logger.debug("COMMAND " + " ".join(cmdline))
    subprocess.check_call(cmdline)


async def arun_cmd(cmdline, logfile: io.TextIOWrapper = sys.stdout, name: str | None = None):
    logger.debug("COMMAND " + " ".join(cmdline))
    proc = await asyncio.create_subprocess_exec(
        *cmdline,
        stdout=asyncio.subprocess.PIPE,
        stderr=asyncio.subprocess.STDOUT,
    )

    async for line in proc.stdout:
        try:
            text = line.decode().rstrip()
        except UnicodeDecodeError:
            text = repr(line)
        logfile.write(text)
        logfile.flush()

    await proc.wait()
    if proc.returncode != 0:
        raise RuntimeError(f"{' '.join(cmdline)} => {proc.returncode}")


class TQDMLogWriter:
    def __init__(self, position: int = 0):
        self.bar = tqdm.tqdm(
            position=position,
            bar_format='{l_bar}{bar} {n_fmt}/{total_fmt} [{elapsed}<{remaining}]'
        )

    def __del__(self):
        self.bar.close()

    def flush(self):
        self.bar.refresh()

    def write(self, line: str):
        if m := re.match(r"^\[(\d+)/(\d+)\] (.+)", line):
            self.bar.n = int(m.group(1))
            self.bar.total = int(m.group(2))
            self.bar.set_description(m.group(3)[:40])
        else:
            self.bar.set_description(line[:40])


class ColorLogWriter:
    def __init__(self, app, file=sys.stdout):
        self.prefix = f"{app.id} | "
        self.file = file
        if app.termcolor is not None:
            self.prefix = f"{app.termcolor}{self.prefix}\033[0m"

    def write(self, line: str):
        self.file.write(f"{self.prefix}{line}\n")

    def flush(self):
        self.file.flush()


def ip_cmd(*cmdline):
    return run_cmd(["sudo", "ip", *cmdline])


@dataclass(frozen=True)
class EthernetInterface:
    name: str
    network_id: str
    mac: bytes | None = None
    ipv4: ipaddress.IPv4Interface | None = None
    ipv6: ipaddress.IPv6Interface | None = None

    def __post_init__(self):
        assert len(self.mac) == 6

    @property
    def pretty_mac(self) -> str:
        return ":".join(map("%02X".__mod__, self.mac))

    @property
    def pretty_peer_mac(self) -> str:
        mac = bytes(b + (1 if i == 4 else 0) for i, b in enumerate(self.mac))
        return ":".join(map("%02X".__mod__, mac))

    def __str__(self) -> str:
        res = f"({self.network_id}) {self.name} :: [{self.pretty_mac}]"
        if self.ipv4:
            res += f" {self.ipv4}"
        if self.ipv6:
            res += f" {self.ipv6}"
        return res

    def tap(self):
        return Tap(**asdict(self))

    def veth(self):
        return Veth(**asdict(self))


class Tap(EthernetInterface):
    def up(self, bridge_name: str):
        logger.info(f"Creating TAP interface {self.name} bridged to {bridge_name}")
        ip_cmd("tuntap", "add", "dev", self.name, "mode", "tap")
        ip_cmd("link", "set", self.name, "up", "master", bridge_name)

    def down(self):
        logger.info(f"Removing TAP interface {self.name}")
        ip_cmd("link", "set", self.name, "nomaster", "down")
        ip_cmd("link", "del", self.name)


class Veth(EthernetInterface):
    def up(self, bridge_name: str):
        logger.info(f"Creating VETH interface {self.name} bridged to {bridge_name}")
        peer = self.name + "br"
        ip_cmd("link", "add", self.name, "type", "veth", "peer", "name", peer)
        ip_cmd("link", "set", peer, "up", "master", bridge_name)
        if self.ipv4 is not None:
            ip_cmd("addr", "add", str(self.ipv4), "dev", self.name)
        if self.ipv6 is not None:
            ip_cmd("addr", "add", str(self.ipv6), "dev", self.name)
        ip_cmd("link", "set", self.name, "up")

    def down(self):
        logger.info(f"Removing VETH interface {self.name}")
        ip_cmd("link", "set", self.name, "down")
        ip_cmd("link", "del", self.name)

@dataclass
class TapBridgeNetwork:
    id: str
    name: str
    ipv4: ipaddress.IPv4Network
    ipv6: ipaddress.IPv6Network

    def __post_init__(self):
        self.taps: list[Tap] = []
        self.veths: list[Veth] = []

    def mketh(self, ifname: str) -> EthernetInterface:
        offset = 1 + len(self.taps) + len(self.veths)
        return EthernetInterface(
            name=ifname,
            network_id=self.id,
            mac=[0x00, 0x00, 0x5e, 0x00, 0x53, offset],
            ipv4=ipaddress.IPv4Interface(
                f"{self.ipv4.network_address + offset}/{self.ipv4.prefixlen}"
            ),
            ipv6=ipaddress.IPv6Interface(
                f"{self.ipv6.network_address + offset}/{self.ipv6.prefixlen}"
            ),
        )

    def create_tap(self) -> EthernetInterface:
        tap_number = len(self.taps)
        tap = self.mketh(f"{self.name}tap{tap_number}").tap()
        self.taps.append(tap)
        return tap

    def create_veth(self) -> EthernetInterface:
        veth_number = len(self.veths)
        veth = self.mketh(f"{self.name}veth{veth_number}").veth()
        self.veths.append(veth)
        return veth

    @property
    def bridge_name(self):
        return self.name + "br"

    def up(self):
        logger.info(f"Creating BRIDGE interface {self.bridge_name}")
        ip_cmd("link", "add", self.bridge_name, "type", "bridge")
        ip_cmd("link", "set", self.bridge_name, "up")

        for tap in self.taps:
            tap.up(self.bridge_name)

        for veth in self.veths:
            veth.up(self.bridge_name)
        logger.info(f"Network {self.name} up")


    def down(self):
        logger.info(f"Removing BRIDGE interface {self.bridge_name}")
        ip_cmd("link", "set", self.bridge_name, "down")

        for veth in self.veths:
            veth.down()

        for tap in self.taps:
            tap.down()

        ip_cmd("link", "del", self.bridge_name)


@dataclass
class Application:
    id: str
    source: Path
    board: str = "native_sim"
    ethernet_if: list[EthernetInterface] = field(default_factory=list)
    extra_build_args: list[str] = field(default_factory=list)
    termcolor: str | None = None

    @property
    def output_dir(self) -> Path:
        return Path("output") / f"{self.id}-{self.board}"

    def get_network_if(self, network_id: str) -> EthernetInterface | None:
        for iface in self.ethernet_if:
            if iface.network_id == network_id:
                return iface
        return None

    @property
    def west_cmd(self) -> list[str]:
        return ["west", "build", "--build-dir", str(self.output_dir)]

    def colorize(self, text):
        return text if self.termcolor is None else f"{self.termcolor}{text}\033[0m"

    def menuconfig(self):
        cmdline = [
            *self.west_cmd,
            "-t", "menuconfig",
        ]
        os.execvp(cmdline[0], cmdline)

    async def build(self, pristine: bool = False, logfile = sys.stdout):
        await arun_cmd(
            name=self.colorize(f"Build {self.id}"),
            logfile=logfile,
            cmdline=[
                *self.west_cmd,
                "--board", self.board,
                str(self.source),
                *(["--pristine"] if pristine else []),
                "--",
                *self.extra_build_args
            ]
        )

    async def clean(self, logfile = sys.stdout):
        await arun_cmd([*self.west_cmd, "--target", "clean"], logfile=logfile)

    async def run(self, logfile = sys.stdout):
        cmdline = [
            str(self.output_dir / "zephyr" / "zephyr.exe"),
        ]

        if self.ethernet_if:
            iface = self.ethernet_if[0]
            cmdline += [
                f"--eth-if={iface.name}",
                f"--mac-addr={iface.pretty_mac}",
                f"--ipv4-addr={iface.ipv4.ip}",
                f"--ipv4-nm={iface.ipv4.netmask}",
            ]

        await arun_cmd(cmdline, name=self.colorize(f"{self.id}"), logfile=logfile)


@dataclass
class Context:
    networks: dict[str, TapBridgeNetwork]
    applications: dict[str, Application]
    name: str | None = None

    @classmethod
    def parse(self, filename: str):
        with open(filename) as f:
            zcomposefile = yaml.safe_load(f)

        networks = {}
        for net_id, net_cfg in zcomposefile["networks"].items():
            networks[net_id] = TapBridgeNetwork(
                id=net_id,
                name=net_cfg.get("name", net_id),
                ipv4=ipaddress.ip_network(net_cfg.get("ipv4", f"192.0.{2+len(networks)}.0/24")),
                ipv6=ipaddress.ip_network(net_cfg.get("ipv6", f"2001:db8:{2+len(networks)}::/64")),
            )
            if net_cfg.get("host-veth"):
                 networks[net_id].create_veth()

        applications = {}
        for i, (app_id, app_cfg) in enumerate(zcomposefile["applications"].items()):
            color = (1+i) & 7
            bold = ((1+i) >> 3) & 1
            args = {
                "id": app_id,
                "source": Path(app_cfg["source"]),
                "ethernet_if": [
                    networks[net].create_tap()
                    for net in app_cfg.get("networks", [])
                ],
                "termcolor": f"\033[3{color}{';1' if bold else ''}m",
            }
            if "board" in app_cfg:
                args["board"] = app_cfg["board"]
            applications[app_id] = Application(**args)

        def substitute_variable(m: re.Match) -> str:
            target_app_id, net, prop = m.group(1).split(':')
            iface = applications[target_app_id].get_network_if(net)

            if prop == "ipv4":
                return str(iface.ipv4.ip)
            elif prop == "ipv6":
                return str(iface.ipv6.ip)
            raise ValueError(f"Unknown property {prop}")

        for app_id, app_cfg in zcomposefile["applications"].items():
            opts = app_cfg.get("extra-build", {})
            extra_build_args = opts.get("args", [])

            for snippet in opts.get("snippets", []):
                extra_build_args.append(f"-DSNIPPET={snippet}")

            for key, value in opts.get("config", {}).items():
                if isinstance(value, str) and value not in "yn":
                    value = f'"{value.replace('"', '\\"')}"'
                extra_build_args.append(f"-DCONFIG_{key}={value}")

            for arg in extra_build_args:
                applications[app_id].extra_build_args.append(
                    re.sub(r"\$\{(.+)\}", substitute_variable, arg)
                )

        return Context(
            networks=networks,
            applications=applications,
            name=zcomposefile.get("name")
        )

    def up(self):
        logger.info(f"Bringing up context {self.name}")

        for net in self.networks.values():
            net.up()

    def down(self):
        for net in self.networks.values():
            net.down()

    async def forall_apps(self, func):
        procs = [
            func(app, logfile=ColorLogWriter(app))
            for app in self.applications.values()
        ]
        await asyncio.gather(*procs)

    async def build(self):
        logger.info(f"Building applications for context {self.name}")
        bars = [TQDMLogWriter(position=i) for i, _ in enumerate(self.applications)]
        await asyncio.gather(*(
            app.build(logfile=bars[i])
            for i, app in enumerate(self.applications.values())
        ))

    async def clean(self):
        logger.info(f"Cleaning applications for context {self.name}")
        await self.forall_apps(Application.clean)

    async def run(self):
        await self.build()
        logger.info(f"Running applications for context {self.name}")
        try:
            await self.forall_apps(Application.run)
        except asyncio.exceptions.CancelledError:
            pass

    def show(self):
        print(f"Context {self.name}")
        print("Applications:")
        for app in self.applications.values():
            print(f" - {app.id} ({app.board} - {app.source})")
            for iface in app.ethernet_if:
                print(f"    - {iface}")
        print("Host network interfaces")
        for net in self.networks.values():
            for veth in net.veths:
                print(f"  - {veth}")


if __name__ == "__main__":
    from sys import argv
    logging.basicConfig(level=logging.INFO)

    ctx = Context.parse("ZCompose.yml")

    if len(argv) < 2:
        print(f"USAGE: {argv[0]} {{up | down}}")
        exit()

    match (action := argv[1]):
        case "show"|"up"|"down":
            getattr(ctx, action)()
        case "build"|"clean"|"run":
            asyncio.run(getattr(ctx, action)())
        case "menuconfig":
            ctx.applications[argv[2]].menuconfig()
        case _:
            print(f"Unknown command {argv[1]}")
